Linked Lists
-------------------------------------------------------------------
Linked List :
- Data Structure that represents a sequence of nodes

Singly Linked List:
- Each node points to the NEXT node in the linked list

Doubly Linked List:
- gives each node pointers to both the next node and previous node

Cons:
- Unlike an array, a linked list does not provide constant time access to particular "index" within the list
---> meaning if you'd like to find the Kth element in the list - you will need to iterate through K elements

Pros:
- you can add and remove items from the beginning of the list in constant time (useful in specific applications)

--------------------------------------------------------------------------

Creating a Linked List :

class Node {

	Node next = null;
	int data;
	
	public Node(int d) {
		data = d;
	}

	void appendToTail(int d) {
		Node end = new Node(d);
		Node n = this;
		
		while (n.next != null) {
		 n = n.next;
		}
		
		n.next = end;
	}
}

--> in the above implementation we dont have a LinkedList data structure.
We access the linked list through a reference to the head Node of the linked list.
- when you implement the linked list this way, you need to be a bit careful.
---> ie what if multiple objects need a reference to the linked list, and then the head of the linked list changes? Some objects might still be pointin to the old head


----> We could, if we chose, implement a LinkedList class that wraps the Node class - this would essentially just have a single member variable : the head Node -- resolving above issues

PS : when discussing a linked list in an interview - you must understand whether it is a singly linked list OR doubly linked list


--------------------------------------------------------------------------------

Deleting a Node from a Singly Linked List

Deleting a node from a Singly linked list is fairly straightforwad
- Given a node n, we find the previous node prev and set prev.next equal to n.next

If the list is Doubly Linked List 
- we must also update n.next to set n.next.prev equal n.prev

PS: remember 
1) to check for the nullPointer
2) to update the head / tail pointer as necessary

PS: If you implement this code in C or C++ or another language that requires the developer to do memory management - consider if the removed node should be deallocated


Node deleteNode(Node head, int d){
	Node n = head;
	
	if (n.data = d) {
		return head.next; /* moved head */
	}
	
	while (n.next != null) {
		if (n.next.data == d){
			n.next = n.next.next;
			return head; /* head didn't change */
		}
		n = n.next;
	}
	return head;
}


-------------------------------------------------------------------------------

:: The "Runner" Technique

- the runner or 2nd pointer technique is used in many linked list problems
-> the runner technique means that you iterate through the linked list with 2 pointers simulteneously, with one ahead of the other 
---> The "fast" node mighe be ahead by a fixed amount or it might be hopping multiple nodes for each node that the "slow" node iterates through
